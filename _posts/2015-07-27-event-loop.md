---
layout: post
title:  "JavaScript中的事件循环"
date:   2015-07-27 13:19:00
comments: true
categories: javascript
---

从我们写下第一行JavaScript代码开始，可能还没写到10行就已经和事件循环打交道了，可是什么是事件循环呢？

# 一个管家的故事
首先来讲一个故事。

一觉醒来，你发现自己穿越了，成为了一个王府的管家。

要把一切打理得井井有条可不是一件容易的事，幸好你有很多仆人可以使唤。

每天开始工作了，你做的第一件事就是把一个任务清单上的所有任务交给不同的仆人去办，同时交给他们一个任务清单，吩咐他们在完成后把完成的情况记录在任务清单上，然后把任务清单交给管家婆。管家婆把任务清单按收到的顺序放好。

当你把手上的任务清单的任务都分配完后，就把任务清单丢掉，然后去问管家婆，“有没有任务清单交到你的手里？”。

如果回答是没有，你会过一会儿再去问管家婆。

如果回答是有，你让管家婆把手里最先收到的任务清单交给你。然后继续按之前的方式分配任务给仆人。

分配完后继续问管家婆要下一张任务清单。

分配任务 => 问管家婆要任务清单 => 分配任务 => 问管家婆要任务清单 => ...

管家原来很好当嘛，不断分配任务出去就好了。

当闹钟把你吵醒后，你才意识到原来这只是一个梦，你不是一个管家，只是一个程序猿，还是继续写JavaScript代码吧。

# 事件循环

当敲下新的一天的第一行代码时，你意识到了，原来自己就是管家手里第一份任务清单的制定者。

管家就是JavaScript引擎，任务清单就是函数，仆人是JavaScript的宿主环境，管家婆是消息队列。

管家把任务清单上的任务分配出去；JavaScript引擎通过堆栈执行函数。管家的第一张任务清单就是JavaScript的主函数（JS中实际上没有主函数的概念，但是第一次加载的所有代码都会一次性执行完毕后才会询问消息队列，相当于外层有一个主函数包裹）。

管家把任务分配给仆人；JavaScript引擎把异步执行的代码交给宿主环境的相关部分（比如定时器，node中的libuv）处理。

仆人完成任务后，把新的任务清单交给管家婆；宿主环境在完成相关操作后把回调函数添加到消息队列中。

管家在分配完任务清单上的任务后，问管家婆要新的任务清单；JavaScript引擎执行完当前函数，堆栈为空时，查看消息队列中是否有新的函数需要执行，一次对消息队列的查看被称为`Tick`。

# 总结
当我们写的JavaScript代码被运行时，加载的所有代码就像被包裹在一个函数（主函数）中一样，首先全部执行。

在执行过程中，需要异步执行的代码交给宿主环境处理，宿主环境处理好后将回调函数添加到消息队列中。

当主函数（实际并不存在）执行完毕后，会查看消息队列中是否有函数需要执行。

如果没有，会不断查看直到有；如果有，就从消息队列中取出这个函数并且执行。

然后继续查看消息队列，直到程序退出。
